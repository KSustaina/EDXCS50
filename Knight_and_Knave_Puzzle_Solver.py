# -*- coding: utf-8 -*-
"""Knight and Knave Puzzle Solver

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bZDbcSkQ4u40Dgtcn5X74WEE8GKAU6kY
"""

def solve_knight_knave_puzzle(puzzle_number):
    """
    Solves a knight and knave logic puzzle for the given puzzle number.

    Args:
        puzzle_number (int): The number of the puzzle to solve (0, 1, 2, or 3).

    Returns:
        list: A list of possible solutions, where each solution is a dictionary
              mapping characters ('A', 'B', 'C') to their type ('knight' or 'knave').
              Returns an empty list if no consistent solution is found.
    """

    solutions = []

    if puzzle_number == 0:
        # Puzzle 0: A says "I am both a knight and a knave."
        for a_type in ["knight", "knave"]:
            a_statement = (a_type == "knight" and a_type == "knave")
            if (a_type == "knight" and a_statement) or (a_type == "knave" and not a_statement):
                solutions.append({"A": a_type})

    elif puzzle_number == 1:
        # Puzzle 1: A says "We are both knaves." B says nothing.
        for a_type in ["knight", "knave"]:
            for b_type in ["knight", "knave"]:
                a_statement = (a_type == "knight" and a_type == "knave" and b_type == "knave")
                if (a_type == "knight" and a_statement) or (a_type == "knave" and not a_statement):
                    solutions.append({"A": a_type, "B": b_type})

    elif puzzle_number == 2:
        # Puzzle 2: A says "We are the same kind." B says "We are of different kinds."
        for a_type in ["knight", "knave"]:
            for b_type in ["knight", "knave"]:
                a_statement = (a_type == "knight" and (a_type == b_type))
                b_statement = (b_type == "knight" and (a_type != b_type))
                if ((a_type == "knight" and a_statement) or (a_type == "knave" and not a_statement)) and \
                   ((b_type == "knight" and b_statement) or (b_type == "knave" and not b_statement)):
                    solutions.append({"A": a_type, "B": b_type})

    elif puzzle_number == 3:
        # Puzzle 3: A says "I am a knight." or "I am a knave." (unknown which)
        #           B says "A said 'I am a knave.'" and "C is a knave."
        #           C says "A is a knight."
        for a_type in ["knight", "knave"]:
            for b_type in ["knight", "knave"]:
                for c_type in ["knight", "knave"]:
                    # Consider B's first statement: "A said 'I am a knave.'"
                    a_said_knave = (a_type == "knave")
                    b_first_statement = (b_type == "knight" and a_said_knave) or (b_type == "knave" and not a_said_knave)

                    # Consider B's second statement: "C is a knave."
                    b_second_statement = (b_type == "knight" and c_type == "knave") or (b_type == "knave" and c_type == "knight")

                    # Consider C's statement: "A is a knight."
                    c_statement = (c_type == "knight" and a_type == "knight") or (c_type == "knave" and a_type == "knave")

                    if b_first_statement and b_second_statement and c_statement:
                        solutions.append({"A": a_type, "B": b_type, "C": c_type})

    else:
        return "Invalid puzzle number."

    return solutions

# Solve each puzzle and print the results
for i in range(4):
    results = solve_knight_knave_puzzle(i)
    print(f"Solutions for Puzzle {i}:")
    if results:
        for solution in results:
            print(solution)
    else:
        print("No consistent solution found.")
    print("-" * 20)

